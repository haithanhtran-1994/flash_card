<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Vocab Master Pro - Study & Review</title>
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        :root { --primary: #2563eb; --success: #16a34a; --warning: #ca8a04; --danger: #ef4444; --bg: #f1f5f9; }
        body { font-family: 'Segoe UI', sans-serif; background: var(--bg); margin: 0; display: flex; flex-direction: column; align-items: center; min-height: 100vh; }
        .container { width: 95%; max-width: 700px; background: white; padding: 25px; border-radius: 16px; box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1); margin: 20px 0; position: relative; }
        .hidden { display: none !important; }
		.status-badge { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); font-size: 1.5rem; display: flex; gap: 5px; z-index: 10; }
        .field-nav { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; min-height: 60px; background: #f8fafc; border-radius: 10px; padding: 0 10px; }
        .field-label { flex: 1; text-align: center; font-size: 0.75rem; color: #94a3b8; padding: 5px; overflow: hidden; }
        .field-active { color: var(--primary); font-size: 1.1rem; font-weight: 800; border-bottom: 3px solid var(--primary); }
		/* --- PH·∫¶N TH√äM M·ªöI V√ÄO STYLE --- */
.card-container {
    position: relative; /* ƒê·ªÉ c√°c n√∫t cƒÉn theo khung n√†y */
    display: flex;
    align-items: center;
    justify-content: center;
}

.card { 
    height: 450px; 
    position: relative; 
    width: 100%; 
    transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1); 
    transform-style: preserve-3d; /* C·ª∞C K·ª≤ QUAN TR·ªåNG: Gi·ªØ kh√¥ng gian 3D */
    cursor: pointer; 
}

.card.is-flipped { 
    transform: rotateY(180deg); 
}

.card-face { 
    position: absolute; 
    width: 100%; 
    height: 100%; 
    -webkit-backface-visibility: hidden; 
    backface-visibility: hidden; 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    justify-content: center; 
    border: 2px solid #e2e8f0; 
    border-radius: 20px; 
    background-color: #ffffff; /* √âp n·ªÅn tr·∫Øng ƒë·∫∑c ƒë·ªÉ kh√¥ng nh√¨n xuy√™n */
    box-sizing: border-box; 
    padding: 20px;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
}

.card-front {
    z-index: 2;
    transform: rotateY(0deg);
}

.card-back { 
    transform: rotateY(180deg); 
    background-color: #ffffff; /* N·ªÅn tr·∫Øng ƒë·∫∑c */
    z-index: 1;
}
		/* Style Furigana */
/* Container chung ƒë·ªÉ l·∫•y m·ª©c trung b√¨nh */
.card-content {
    font-size: 1.8rem; /* M·ª©c n·ªÅn trung b√¨nh */
    line-height: 1.6;
    text-align: center;
}

/* √âp ti·∫øng Nh·∫≠t (Kanji) to h·∫≥n l√™n ƒë·ªÉ nh√¨n r√µ n√©t */
.lang-jp {
    font-size: 2.3rem !important; 
    font-weight: 500;
}

/* √âp ti·∫øng Vi·ªát nh·ªè l·∫°i cho thanh tho√°t, kh√¥ng b·ªã th√¥ */
.lang-vi {
    font-size: 1.6rem !important;
    color: #334155;
}

/* S·ª≠a l·∫°i Furigana (rt) cho d·ªÖ nh√¨n */
ruby rt {
    font-size: 0.55em; /* TƒÉng t·ª´ 0.45 l√™n 0.55 ƒë·ªÉ d·ªÖ ƒë·ªçc h∆°n */
    color: var(--primary);
    font-weight: normal;
    padding-bottom: 2px;
}
		.furigana-hidden rt { visibility: hidden; }
		.flip-hint { position: absolute; bottom: 15px; font-size: 0.7rem; color: #94a3b8; font-style: italic; }
		.btn-furi { background: #0ea5e9; color: white; padding: 4px 8px; font-size: 0.7rem; border-radius: 10px; border: none; cursor: pointer; margin-left: 10px; }
        .speaker-icon { font-size: 1.8rem; cursor: pointer; color: var(--primary); margin-top: 10px; background: #eff6ff; border: 2px solid var(--primary); border-radius: 50%; width: 50px; height: 50px; display: flex; align-items: center; justify-content: center; -webkit-tap-highlight-color: transparent; }
.nav-arrow {
    position: absolute;
    /* ƒê·∫©y xu·ªëng ƒë√°y th·∫ª */
    bottom: 20px; 
    /* B·ªè c√°i top 50% c≈© ƒëi */
    top: auto;
    transform: none; 
    
    z-index: 10;
    width: 45px;
    height: 45px;
    background: rgba(0, 0, 0, 0.05); /* M√†u n·ªÅn m·ªù nh·∫π */
    border-radius: 8px; /* Bo g√≥c vu√¥ng nh·∫π cho hi·ªán ƒë·∫°i */
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
}

.nav-arrow:hover {
    background: rgba(0, 0, 0, 0.1);
}

.arrow-left {
    left: 20px; /* C√°ch l·ªÅ tr√°i 20px */
}

.arrow-right {
    right: 20px; /* C√°ch l·ªÅ ph·∫£i 20px */
}
        .btn-group { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
        button { padding: 14px; border: none; border-radius: 10px; cursor: pointer; font-weight: 600; transition: transform 0.1s; -webkit-tap-highlight-color: transparent; }
        button:active { transform: scale(0.98); }
        .btn-learned { background: var(--warning); color: white; }
        .btn-mastered { background: var(--success); color: white; }
        .btn-forgot { background: #64748b; color: white; }
        .btn-next-prev { background: var(--primary); color: white; grid-column: span 3; display: flex; justify-content: space-between; align-items: center; padding: 0; overflow: hidden; border-radius: 10px;}
		.btn-next-prev button { background: none !important; color: white !important; border: none; height: 100%; padding: 14px 25px; cursor: pointer; font-weight: bold; font-size: 0.9rem }
		#word-counter, #review-counter { color: white; font-weight: bold; min-width: 60px; text-align: center; }
        .menu-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 20px; }
        .btn-menu { background: #334155; color: white; padding: 12px; }
        .voice-settings { margin-top: 10px; font-size: 0.8rem; display: flex; flex-wrap: wrap; gap: 15px; align-items: center; background: #f8fafc; padding: 10px; border-radius: 8px; color: #64748b; }
        .quiz-item { margin-bottom: 25px; padding: 20px; border: 1px solid #e2e8f0; border-radius: 12px; scroll-margin-top: 80px; }
        .option-btn { width: 100%; text-align: left; padding: 12px; margin-top: 8px; border: 1px solid #cbd5e1; background: #fff; border-radius: 8px; }
        .option-btn.selected { border: 2px solid var(--primary); background: #f0f7ff; }
        .option-btn.correct-ans { background: #dcfce7 !important; border-color: #22c55e !important; color: #166534; }
        .option-btn.wrong-ans { background: #fee2e2 !important; border-color: #ef4444 !important; color: #991b1b; }
        #quiz-timer-box { position: sticky; top: 10px; z-index: 100; background: var(--danger); color: white; padding: 10px; border-radius: 10px; text-align: center; font-weight: bold; margin-bottom: 15px; font-size: 1.2rem; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        #quiz-result-summary { background: #f8fafc; padding: 15px; border-radius: 12px; border: 1px solid #e2e8f0; margin-bottom: 20px; }
        .dot-nav { display: inline-block; width: 30px; height: 30px; line-height: 30px; text-align: center; border-radius: 50%; margin: 4px; cursor: pointer; color: white; font-weight: bold; font-size: 0.8rem; }
        .btn-finish { background: #1e293b; color: white; width: 100%; padding: 15px; margin-top: 20px; font-size: 1.1rem; }
        .speed-val { font-weight: bold; color: var(--primary); min-width: 35px; display: inline-block; }
        .action-panel { margin-top: 20px; padding: 15px; border-top: 2px solid #e2e8f0; display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .btn-sync { background: #16a34a; color: white; font-size: 0.8rem; padding: 10px; width: 100%; border-radius: 8px; font-weight: bold;}
        .sync-section { margin-top: 20px; padding: 15px; background: #f0fdf4; border: 1px solid #bbf7d0; border-radius: 12px; }
        .scenario-box { border: 1px solid #e2e8f0; padding: 15px; border-radius: 10px; margin-top: 15px; background: #f8fafc; position: relative; }
        .scenario-title { font-weight: bold; color: #334155; margin-bottom: 10px; display: block; }
        .remove-scenario { position: absolute; top: 10px; right: 10px; color: var(--danger); cursor: pointer; font-size: 0.8rem; }
        .select-group { margin-bottom: 10px; }
        .select-group label { display: block; font-size: 0.75rem; color: #64748b; margin-bottom: 4px; }
        .exclude-list { display: flex; flex-wrap: wrap; gap: 8px; }
        .exclude-item { font-size: 0.75rem; background: #fff; border: 1px solid #cbd5e1; padding: 2px 6px; border-radius: 4px; display: flex; align-items: center; gap: 4px; }
        .btn-autoplay { background: #8b5cf6; color: white; grid-column: span 3; margin-top: 5px; }
		.status-star { color: var(--warning); }
		.status-check { color: var(--success); }
		.review-mastered { background: var(--warning); color: white; }
        .db-view-container { max-width: 95% !important; width: 1200px !important; }
        .excel-table-wrapper { overflow: auto; max-height: 500px; border: 1px solid #ddd; margin-bottom: 15px; }
        .excel-table { width: 100%; border-collapse: collapse; background: white; font-size: 0.9rem; }
        .excel-table th { position: sticky; top: 0; background: #f1f5f9; z-index: 5; border: 1px solid #cbd5e1; padding: 8px; }
        .excel-table td { border: 1px solid #cbd5e1; padding: 5px; min-width: 100px; outline: none; }
        .excel-table td:focus { background: #fffbeb; box-shadow: inset 0 0 0 2px var(--primary); }
        .btn-db-action { padding: 8px 16px; border-radius: 6px; font-size: 0.85rem; }
        .btn-confirm { background: var(--success); color: white; }
        .btn-cancel { background: #94a3b8; color: white; }
        .btn-add-row { background: var(--primary); color: white; margin-bottom: 10px; }
		.btn-delete-row { background: var(--danger); color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.7rem; cursor: pointer;}
        
        /* OVERLAY M·ªöI ƒê·ªÇ K√çCH HO·∫†T √ÇM THANH TR√äN IOS */
        #audio-unlock { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 9999; display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; text-align: center; padding: 20px; }
    </style>
</head>
<body>

    <div id="audio-unlock" class="hidden">
        <h2>üîä S·∫µn s√†ng h·ªçc t·∫≠p</h2>
        <p>Nh·∫•n n√∫t b√™n d∆∞·ªõi ƒë·ªÉ k√≠ch ho·∫°t √¢m thanh tr√™n thi·∫øt b·ªã n√†y.</p>
        <button onclick="unlockAudio()" style="background: var(--success); color: white; padding: 20px 40px; font-size: 1.2rem;">B·∫ÆT ƒê·∫¶U NGAY</button>
    </div>

    <div id="setup-screen" class="container">
        <h2 style="text-align: center;">üìÇ C√†i ƒë·∫∑t Database</h2>
        <div style="border: 2px dashed #cbd5e1; padding: 30px; text-align: center; border-radius: 12px;">
            <p style="margin-top:0; color:#64748b;">N·∫°p file Excel (.xlsx)</p>
            <p style="font-size: 0.7rem; color: #94a3b8;">(C·ªôt 1: STT, C·ªôt 2: T·ª´ v·ª±ng ch√≠nh)</p>
            <input type="file" id="fileInput" accept=".xlsx" />
        </div>
        <div class="sync-section">
            <h4 style="margin:0 0 10px 0; color:#16a34a;">üîÑ ƒê·ªìng b·ªô gi·ªØa c√°c m√°y</h4>
            <button class="btn-sync" onclick="exportFullBackup()">üíæ Xu·∫•t to√†n b·ªô d·ªØ li·ªáu (Backup)</button>
            <button class="btn-sync" style="background:#0891b2" onclick="document.getElementById('backupInput').click()">üì• Nh·∫≠p t·ª´ file Backup (.json)</button>
            <input type="file" id="backupInput" accept=".json" class="hidden" onchange="importFullBackup(event)" />
        </div>
    </div>

    <div id="study-screen" class="container hidden">
        <div id="status-display" class="status-badge"></div>
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h3 id="mode-title" style="margin: 0; color: var(--primary); font-size: 0.9rem; text-transform: uppercase;">Ch·∫ø ƒë·ªô h·ªçc t·∫≠p</h3>
            <button class="btn-db-action" style="background: #334155; color: white; padding: 5px 10px;" onclick="showDatabaseView()">üëÅÔ∏è Xem Database</button>
        </div>
        
        <div class="field-nav">
            <div id="prev-field" class="field-label">---</div>
            <div id="curr-field" class="field-label field-active">---</div>
            <div id="next-field" class="field-label">---</div>
        </div>

<div class="card-container">
    <button class="nav-arrow arrow-left" onclick="changeField(-1, event)">‚ùÆ</button>
    <button class="nav-arrow arrow-right" onclick="changeField(1, event)">‚ùØ</button>
    <div class="card" id="main-card" onclick="handleCardClick(event)">
        <div class="card-face card-front">
            <div id="display-text" class="card-content">---</div>
            <span class="flip-hint" id="flip-hint-text">Ch·∫°m ƒë·ªÉ l·∫≠t m·∫∑t sau</span>
        </div>
        <div class="card-face card-back">
            <div id="display-text-back" class="card-content">---</div>
            <span class="flip-hint">Ch·∫°m ƒë·ªÉ quay l·∫°i m·∫∑t tr∆∞·ªõc</span>
        </div>
    </div>
</div>

<div class="voice-settings">
    <span>T·ªëc ƒë·ªô: <input type="range" id="voiceRate" min="0.25" max="3" step="0.25" value="1" oninput="document.getElementById('speed-display').innerText = this.value + 'x'"> 
        <span id="speed-display" class="speed-val">1x</span>
    </span>
    <label><input type="checkbox" id="autoSpeak" checked> T·ª± ƒë·ªông h·ªçc</label>
    <button class="btn-furi" id="toggleFuri" onclick="toggleFuriganaDisplay()">Furigana: ON</button>
    <button class="btn-furi" style="background: var(--primary); margin-left:5px" onclick="handleSpeak(event)">üîä ƒê·ªçc</button> 
</div>

<div id="study-controls" class="btn-group" style="margin-top: 15px;">
    <button id="btn-learned" class="btn-learned" onclick="setStatus('learned')">‚≠ê ƒê√£ h·ªçc</button>
    <button id="btn-mastered" class="btn-mastered" onclick="setStatus('mastered')">‚úÖ ƒê√£ nh·ªõ</button>
    <button id="btn-forgot" class="btn-forgot" onclick="setStatus(null)">Qu√™n r·ªìi üò¢</button>
    <div class="btn-next-prev">
        <button onclick="handlePrev()">‚ùÆ TR∆Ø·ªöC</button>				
        <span id="word-counter">0 / 0</span>
        <button onclick="handleNext()">SAU ‚ùØ</button>
    </div>
</div>

<div id="review-controls" class="btn-group hidden" style="margin-top: 15px; display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px;">
    <button class="btn-mastered review-mastered" onclick="setStatus('mastered')" style="width: 100%; padding: 10px 5px;">‚≠ê ƒê√£ nh·ªõ</button>
    
    <button class="btn-forgot" onclick="setStatus(null)" style="width: 100%; padding: 10px 5px;">Qu√™n r·ªìi üò¢</button>
    
    <div id="random-multi-wrap" style="display: flex; align-items: center; justify-content: center; background: #f1f5f9; border-radius: 8px; border: 1px solid #e2e8f0; padding: 0 5px;">
        <label style="font-size: 0.75rem; color: #475569; cursor: pointer; display: flex; align-items: center; gap: 3px; line-height: 1.2;">
            <input type="checkbox" id="randomMulti"> üîÄ Random t∆∞ÃÄ nhi√™ÃÄu nghiÃÉa
        </label>
    </div>

    <div class="btn-next-prev" style="grid-column: span 3; margin-top: 5px;">
        <button onclick="handlePrev()">‚ùÆ TR∆Ø·ªöC</button>
        <span id="review-counter">0 / 0</span>
        <button onclick="handleNext()">SAU ‚ùØ</button>
    </div>
    
    <button id="btn-autoplay" class="btn-autoplay" onclick="toggleAutoPlay()" style="grid-column: span 3;">‚ñ∂ T·ª± ƒë·ªông ph√°t</button>
</div>
        <div class="menu-grid">
            <button id="btn-to-review" class="btn-menu" onclick="switchMode('review')">üîÑ Chuy·ªÉn sang √în t·∫≠p</button>
            <button id="btn-to-study" class="btn-menu hidden" onclick="switchMode('study')">üìö Quay l·∫°i H·ªçc t·∫≠p</button>
            <button class="btn-menu" onclick="showQuizScreen()">üìù Tr·∫Øc nghi·ªám</button>
        </div>

        <div class="action-panel">
            <button class="btn-sync" onclick="exportFullBackup()" style="background:#6366f1">üíæ Backup nhanh (.json)</button>
            <button class="btn-sync" onclick="showAddFromFile()" style="background:#8b5cf6">‚ûï Th√™m t·ª´ v√†o DB</button>
        </div>
        
        <div id="add-file-panel" class="hidden" style="margin-top: 20px; padding: 15px; background: #fefce8; border: 1px solid #fef08a; border-radius: 12px;">
            <h4 style="margin: 0 0 10px 0;">‚ûï Th√™m t·ª´ v·ª±ng t·ª´ File</h4>
            <input type="file" id="addWordsFileInput" accept=".xlsx" style="font-size: 0.8rem; margin-bottom: 10px; width: 100%;">
            <div style="display: flex; gap: 10px;">
                <button onclick="confirmAddFromFile()" style="background: var(--success); color: white; padding: 8px; flex: 1;">X√°c nh·∫≠n Th√™m</button>
                <button onclick="hideAddFromFile()" style="background: #94a3b8; color: white; padding: 8px; flex: 1;">H·ªßy b·ªè</button>
            </div>
        </div>

        <button onclick="resetDatabase()" style="background:none; color:#94a3b8; margin-top:15px; font-size:10px; border:none; width:100%;">[X√≥a Database]</button>
    </div>

    <div id="db-view-screen" class="container db-view-container hidden">
        <h3>üìä Qu·∫£n l√Ω Database Vocab</h3>
        <button class="btn-add-row" onclick="addRowToExcel()">‚ûï Th√™m h√†ng m·ªõi</button>
        <div class="excel-table-wrapper">
            <table class="excel-table" id="excel-table">
                <thead id="excel-thead"></thead>
                <tbody id="excel-tbody"></tbody>
            </table>
        </div>
        <div style="display: flex; gap: 10px; justify-content: flex-end;">
            <button class="btn-db-action btn-confirm" onclick="saveExcelChanges()">X√°c nh·∫≠n (L∆∞u)</button>
            <button class="btn-db-action btn-cancel" onclick="exitDatabaseView()">Tho√°t</button>
        </div>
    </div>

    <div id="quiz-screen" class="container hidden">
        <h2 id="quiz-header-title">üìù Tr·∫Øc nghi·ªám</h2>
        <div id="quiz-setup">
            <div style="margin-bottom: 15px;">
                S·ªë c√¢u: <input type="number" id="quizCount" placeholder="T·∫•t c·∫£" style="width: 80px; padding: 8px; border: 1px solid #cbd5e1; border-radius: 8px;">
                TGian/c√¢u (s): <input type="number" id="timePerQuestion" value="10" style="width: 60px; padding: 8px; border: 1px solid #cbd5e1; border-radius: 8px;">
                <button onclick="addScenario()" style="background: var(--primary); color: white; padding: 8px 15px; font-size: 0.8rem; margin-left: 10px;">+ Th√™m k·ªãch b·∫£n</button>
            </div>
            <div id="scenarios-list"></div>
            <div style="margin-top: 20px; display: flex; gap: 10px;">
                <button onclick="startQuiz()" style="background: var(--success); color: white; flex: 1;">B·∫Øt ƒë·∫ßu</button>
                <button onclick="exitQuiz()" style="background: #94a3b8; color: white; flex: 1;">H·ªßy</button>
            </div>
        </div>

        <div id="quiz-playing" class="hidden">
            <div id="quiz-timer-box">‚è± Th·ªùi gian c√≤n l·∫°i: <span id="time-left">00:00</span></div>
            <div id="quiz-result-summary" class="hidden"></div>
            <div id="quiz-container"></div>
            <button id="quiz-finish-btn" class="btn-finish" onclick="finishQuiz()">Xong (N·ªôp b√†i)</button>
            <button id="quiz-back-btn" class="btn-finish" style="background: #64748b; margin-top: 10px;" onclick="exitQuiz()">Quay l·∫°i</button>
        </div>
    </div>

<script>
    const SUPABASE_URL = 'https://xolhvdgltrhkixuwaipp.supabase.co';
    const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhvbGh2ZGdsdHJoa2l4dXdhaXBwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njc2MTk4MTMsImV4cCI6MjA4MzE5NTgxM30.A-o0LI-LkorVerHMkDjCwNTJLONeYJAnZdEB1GLgaco';
    const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

    let rawData = [], headers = [], currentWordIndex = 0, currentFieldIndex = 1;
    let reviewPool = [], reviewIndex = 0;
    let stats = JSON.parse(localStorage.getItem('vocab_stats')) || {}; 
    let currentMode = 'study';
    let scenarios = JSON.parse(localStorage.getItem('quiz_scenarios')) || [];
    const synth = window.speechSynthesis;
    let isAutoPlaying = false;
    let quizInterval;
    let quizData = [];
    let userAnswers = {};
    let isDataChanged = false;
    let availableVoices = [];

    let hotkeys = JSON.parse(localStorage.getItem('vocab_hotkeys')) || {
        'next': 'arrowright', 'prev': 'arrowleft', 'learned': '1', 'mastered': '2',
        'forgot': '3', 'speak': 'r', 'fieldNext': 'arrowdown', 'fieldPrev': 'arrowup'
    };
	let groupMarkers = []; // L∆∞u h√†ng th·ª© 2 t·ª´ Excel
	let isFuriVisible = true;
	
function parseFurigana(text) {
    if (!text) return "";

    // 1. Chuy·ªÉn ƒë·ªïi k√Ω t·ª± xu·ªëng d√≤ng (Alt+Enter t·ª´ Excel) th√†nh th·∫ª <br>
    let formattedText = text.toString().replace(/\n/g, "<br>");

    // 2. Regex chuy·ªÉn ƒë·ªïi Kanji(Furigana) th√†nh th·∫ª ruby
    // S·ª≠ d·ª•ng ƒëo·∫°n m√£ n√†y ƒë·ªÉ ƒë·∫£m b·∫£o x·ª≠ l√Ω ƒë∆∞·ª£c c·∫£ xu·ªëng d√≤ng b√™n trong chu·ªói
    return formattedText.replace(/([^\x00-\x7F]+)\(([^)]+)\)/g, '<ruby>$1<rt>$2</rt></ruby>');
}
	function toggleFuriganaDisplay() {
		isFuriVisible = !isFuriVisible;
		const btn = document.getElementById('toggleFuri');
		const contents = document.querySelectorAll('.card-content');
		btn.innerText = isFuriVisible ? "Furigana: ON" : "Furigana: OFF";
		contents.forEach(c => isFuriVisible ? c.classList.remove('furigana-hidden') : c.classList.add('furigana-hidden'));
	}

    // Load voices cho iPhone
	function loadVoices() {
		availableVoices = synth.getVoices();
	}
	
	// Quan tr·ªçng: iOS c·∫ßn s·ª± ki·ªán n√†y
	if (speechSynthesis.onvoiceschanged !== undefined) {
		speechSynthesis.onvoiceschanged = loadVoices;
	}
	// Ch·∫°y ngay l·∫≠p t·ª©c m·ªôt l·∫ßn
	loadVoices();

	window.onload = async function() {
		if (typeof loadVoices === 'function') loadVoices();
		console.log("=== B·∫ÆT ƒê·∫¶U KI·ªÇM TRA D·ªÆ LI·ªÜU CLOUD ===");
	
		try {
			// 1. T·∫£i Headers v√† Ti·∫øn ƒë·ªô
			const { data: prog, error: pErr } = await supabaseClient
				.from('user_progress')
				.select('*')
				.eq('id', 'current_user')
				.maybeSingle(); // D√πng maybeSingle ƒë·ªÉ tr√°nh l·ªói n·∫øu ch∆∞a c√≥ d√≤ng n√†o
			
			if (pErr) console.error("L·ªói truy v·∫•n user_progress:", pErr);
			
			if (prog) {
				stats = prog.stats || {};
				headers = prog.headers || [];
				currentWordIndex = prog.current_index || 0;
				groupMarkers = prog.extra_data?.groupMarkers || [];
				console.log("-> ƒê√£ l·∫•y Headers t·ª´ Cloud:", headers);
			} else {
				console.warn("-> Kh√¥ng t√¨m th·∫•y d√≤ng 'current_user' trong b·∫£ng user_progress");
			}
	
			// 2. T·∫£i d·ªØ li·ªáu t·ª´ v·ª±ng
			const { data: vocab, error: vErr } = await supabaseClient
				.from('hoc_tap')
				.select('*')
				.order('row_index', { ascending: true });
			
			if (vErr) console.error("L·ªói truy v·∫•n hoc_tap:", vErr);
	
			// 3. LOGIC KI·ªÇM TRA CH·∫∂T CH·∫º
			const hasVocab = vocab && vocab.length > 0;
			const hasHeaders = headers && headers.length > 0;
	
			console.log("K·∫æT QU·∫¢ KI·ªÇM TRA:", { hasVocab: hasVocab, vocabCount: vocab?.length, hasHeaders: hasHeaders });
	
			if (hasVocab && hasHeaders) {
				console.log("=> ƒê·ª¶ ƒêI·ªÄU KI·ªÜN. ƒêang n·∫°p d·ªØ li·ªáu...");
				
				rawData = vocab.map(row => {
					let obj = {};
					headers.forEach((h, i) => { 
						obj[h] = row[`col${i+1}`] || "N.A"; 
					});
					return obj;
				});
	
				// ·∫®n m√†n Setup, hi·ªán m√†n Study
				document.getElementById('setup-screen').classList.add('hidden');
				document.getElementById('study-screen').classList.remove('hidden');
				
				// C·∫≠p nh·∫≠t hi·ªÉn th·ªã
				if (typeof updateDisplay === 'function') updateDisplay();
				
			} else {
				// TH√îNG B√ÅO CHI TI·∫æT L·ªñI RA CONSOLE ƒê·ªÇ DEBUG
				let reason = "";
				if (!hasHeaders) reason += "[Thi·∫øu Headers] ";
				if (!hasVocab) reason += "[Thi·∫øu T·ª´ v·ª±ng trong b·∫£ng hoc_tap] ";
				
				console.error("D·ª´ng l·∫°i ·ªü m√†n h√¨nh Setup v√¨:", reason);
				
				// N·∫øu b·∫°n mu·ªën √©p n√≥ lu√¥n hi·ªán m√†n setup khi l·ªói:
				document.getElementById('setup-screen').classList.remove('hidden');
				document.getElementById('study-screen').classList.add('hidden');
				
				if (hasHeaders && !hasVocab) {
					alert("C·∫•u tr√∫c c·ªôt ƒë√£ c√≥ nh∆∞ng ch∆∞a c√≥ t·ª´ v·ª±ng. Vui l√≤ng ch·ªçn file Excel ƒë·ªÉ n·∫°p l·∫°i!");
				}
			}
		} catch (err) {
			console.error("L·ªñI H·ªÜ TH·ªêNG:", err);
		}
	};
	async function syncToCloud() {
		console.log("ƒêang ƒë·ªìng b·ªô l√™n Cloud...");
		const { error } = await supabaseClient.from('user_progress').upsert({
			id: 'current_user',
			stats: stats,
			headers: headers, // L∆∞u m·∫£ng ti√™u ƒë·ªÅ c·ªôt
			current_index: currentWordIndex,
			extra_data: { groupMarkers: groupMarkers } // L∆∞u quy t·∫Øc l·∫≠t th·∫ª
		});
		
		if (error) {
			console.error("L·ªói syncToCloud:", error);
		} else {
			console.log("ƒê√£ l∆∞u c·∫•u tr√∫c v√† ti·∫øn ƒë·ªô l√™n Cloud!");
		}
	}
    function unlockAudio() {
        // Ph√°t m·ªôt √¢m thanh r·ªóng ƒë·ªÉ "m·ªìi" iPhone
        const utter = new SpeechSynthesisUtterance("");
        synth.speak(utter);
        document.getElementById('audio-unlock').classList.add('hidden');
        initApp();
    }

    // --- DATABASE VIEW LOGIC ---
    function showDatabaseView() {
        isDataChanged = false;
        document.getElementById('study-screen').classList.add('hidden');
        document.getElementById('db-view-screen').classList.remove('hidden');
        renderExcelTable();
    }

    function renderExcelTable() {
        const thead = document.getElementById('excel-thead');
        const tbody = document.getElementById('excel-tbody');
        thead.innerHTML = ''; tbody.innerHTML = '';
        let trH = document.createElement('tr');
        headers.forEach(h => {
            let th = document.createElement('th');
            th.innerText = h;
            trH.appendChild(th);
        });
		let thAct = document.createElement('th');
		thAct.innerText = "Thao t√°c";
		trH.appendChild(thAct);
        thead.appendChild(trH);

        rawData.forEach((row, rIdx) => {
            let trB = document.createElement('tr');
            headers.forEach(h => {
                let td = document.createElement('td');
                td.contentEditable = "true";
                td.innerText = row[h] || "";
                td.oninput = () => { isDataChanged = true; };
                trB.appendChild(td);
            });
			let tdAct = document.createElement('td');
			tdAct.style.textAlign = "center";
			tdAct.innerHTML = `<button class="btn-delete-row" onclick="deleteExcelRow(this)">X√≥a</button>`;
			trB.appendChild(tdAct);
            tbody.appendChild(trB);
        });
    }

	function deleteExcelRow(btn) {
		if(confirm("B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a h√†ng n√†y?")) {
			btn.closest('tr').remove();
			isDataChanged = true;
		}
	}

    function addRowToExcel() {
        const tbody = document.getElementById('excel-tbody');
        let trB = document.createElement('tr');
        headers.forEach(() => {
            let td = document.createElement('td');
            td.contentEditable = "true";
            td.oninput = () => { isDataChanged = true; };
            trB.appendChild(td);
        });
		let tdAct = document.createElement('td');
        tdAct.style.textAlign = "center";
        tdAct.innerHTML = `<button class="btn-delete-row" onclick="deleteExcelRow(this)">X√≥a</button>`;
        trB.appendChild(tdAct);
        tbody.appendChild(trB);
        isDataChanged = true;
    }

    function saveExcelChanges() {
        if (isDataChanged) {
            if (!confirm("B·∫°n c√≥ ƒë·ªìng √Ω l∆∞u c√°c thay ƒë·ªïi n√†y kh√¥ng?")) return;
        }
        const rows = document.querySelectorAll('#excel-tbody tr');
        let newData = [];
        rows.forEach(tr => {
            let rowObj = {};
            const cells = tr.querySelectorAll('td');
            headers.forEach((h, i) => {
                rowObj[h] = cells[i].innerText.trim();
            });
            if (Object.values(rowObj).some(v => v !== "")) {
                newData.push(rowObj);
            }
        });
        rawData = newData;
        localStorage.setItem('vocab_data', JSON.stringify(rawData));
        isDataChanged = false;
        alert("ƒê√£ l∆∞u d·ªØ li·ªáu!");
        initApp();
        exitDatabaseView();
    }

    function exitDatabaseView() {
        if (isDataChanged) {
            if (confirm("D·ªØ li·ªáu ƒë√£ thay ƒë·ªïi, b·∫°n c√≥ mu·ªën L∆ØU tr∆∞·ªõc khi tho√°t kh√¥ng?")) {
                saveExcelChanges();
                return;
            }
        }
        document.getElementById('db-view-screen').classList.add('hidden');
        document.getElementById('study-screen').classList.remove('hidden');
    }

    function showAddFromFile() { document.getElementById('add-file-panel').classList.remove('hidden'); }
    function hideAddFromFile() { document.getElementById('add-file-panel').classList.add('hidden'); }
    
    function confirmAddFromFile() {
        const fileInput = document.getElementById('addWordsFileInput');
        if (!fileInput.files.length) { alert("Vui l√≤ng ch·ªçn file!"); return; }
        const reader = new FileReader();
        reader.onload = (e) => {
            const workbook = XLSX.read(new Uint8Array(e.target.result), {type: 'array'});
            const incomingData = XLSX.utils.sheet_to_json(workbook.Sheets[workbook.SheetNames[0]], {defval: "N.A"});
            if (incomingData.length > 0) {
                const incomingHeaders = Object.keys(incomingData[0]);
                if (incomingHeaders.length !== headers.length) {
                    alert(`L·ªói: S·ªë c·ªôt kh√¥ng kh·ªõp!`);
                    return;
                }
                const standardizedData = incomingData.map(row => {
                    let newRow = {};
                    incomingHeaders.forEach((h, i) => { newRow[headers[i]] = row[h]; });
                    return newRow;
                });
                rawData = [...rawData, ...standardizedData];
                localStorage.setItem('vocab_data', JSON.stringify(rawData));
                alert(`ƒê√£ n·ªëi th√™m ${standardizedData.length} t·ª´!`);
                hideAddFromFile();
                initApp();
            }
        };
        reader.readAsArrayBuffer(fileInput.files[0]);
    }

    function exportFullBackup() {
        if (!rawData.length) { alert("Ch∆∞a c√≥ d·ªØ li·ªáu!"); return; }
        const fullData = {
            vocab_data: rawData, vocab_headers: headers, vocab_stats: stats,
            vocab_hotkeys: hotkeys, quiz_scenarios: scenarios, export_date: new Date().toLocaleString()
        };
        const blob = new Blob([JSON.stringify(fullData)], {type: "application/json"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `Vocab_Backup_${new Date().toISOString().slice(0,10)}.json`;
        a.click();
    }

    function importFullBackup(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                localStorage.setItem('vocab_data', JSON.stringify(data.vocab_data));
                localStorage.setItem('vocab_headers', JSON.stringify(data.vocab_headers));
                localStorage.setItem('vocab_stats', JSON.stringify(data.vocab_stats || {}));
                alert("Th√†nh c√¥ng!");
                location.reload();
            } catch (err) { alert("L·ªói!"); }
        };
        reader.readAsText(file);
    }

    window.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.contentEditable === "true") return;
        const key = e.key.toLowerCase();
        if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' '].includes(key)) e.preventDefault();
        if (key === hotkeys.next) handleNext();
        else if (key === hotkeys.prev) handlePrev();
        else if (key === hotkeys.learned) setStatus('learned');
        else if (key === hotkeys.mastered) setStatus('mastered');
        else if (key === hotkeys.forgot) setStatus(null);
        else if (key === hotkeys.speak) speakText();
        else if (key === hotkeys.fieldNext) changeField(1);
        else if (key === hotkeys.fieldPrev) changeField(-1);
    });

    function handleNext() { if (currentMode === 'study') moveWord(1); else nextReviewWord(); }
    function handlePrev() { if (currentMode === 'study') moveWord(-1); else prevReviewWord(); }

	document.getElementById('fileInput').addEventListener('change', (e) => {
		const reader = new FileReader();
		reader.onload = async (event) => {
			const workbook = XLSX.read(new Uint8Array(event.target.result), {type: 'array'});
			const sheet = workbook.Sheets[workbook.SheetNames[0]];
			
			// ƒê·ªçc to√†n b·ªô d∆∞·ªõi d·∫°ng m·∫£ng ƒë·ªÉ d·ªÖ l·ªçc h√†ng tr·ªëng
			const allData = XLSX.utils.sheet_to_json(sheet, {header: 1, defval: ""});
			
			// B∆Ø·ªöC QUAN TR·ªåNG: Lo·∫°i b·ªè nh·ªØng h√†ng ho√†n to√†n tr·ªëng (kh√¥ng c√≥ ch·ªØ n√†o)
			const cleanData = allData.filter(row => row.some(cell => String(cell).trim() !== ""));
	
			if (cleanData.length >= 2) {
				headers = cleanData[0];      // H√†ng 1
				groupMarkers = cleanData[1]; // H√†ng 2
				
				// Ch·ªâ l·∫•y d·ªØ li·ªáu t·ª´ h√†ng 3 tr·ªü ƒëi
				const dataRows = cleanData.slice(2); 
				
				rawData = dataRows.map(row => {
					let obj = {};
					headers.forEach((h, i) => { 
						obj[h] = String(row[i] || "N.A"); 
					});
					return obj;
				});
	
				// Chu·∫©n b·ªã d·ªØ li·ªáu cho Supabase (col1, col2, col3...)
				const toInsert = rawData.map((row, i) => {
					let dbRow = { row_index: i };
					headers.forEach((h, index) => {
						dbRow[`col${index+1}`] = row[h];
					});
					return dbRow;
				});
	
				try {
					// 1. X√≥a s·∫°ch d·ªØ li·ªáu c≈© tr√™n Cloud
					await supabaseClient.from('hoc_tap').delete().neq('row_index', -1);
					
					// 2. ƒê·∫©y d·ªØ li·ªáu m·ªõi (ƒë√£ l·ªçc s·∫°ch h√†ng tr·ªëng)
					const { error } = await supabaseClient.from('hoc_tap').insert(toInsert);
					if (error) throw error;
	
					// 3. ƒê·ªìng b·ªô headers v√† quy t·∫Øc l·∫≠t th·∫ª (groupMarkers)
					await syncToCloud(); 
	
					// Th√¥ng b√°o ƒë√∫ng s·ªë l∆∞·ª£ng h√†ng th·ª±c t·∫ø (·ªü ƒë√¢y c·ªßa b·∫°n s·∫Ω b√°o l√† 6)
					alert("‚úÖ ƒê√£ ƒë·ªìng b·ªô " + rawData.length + " t·ª´ v·ª±ng l√™n Cloud!");
					document.getElementById('audio-unlock').classList.remove('hidden');
				} catch (err) {
					console.error("L·ªói Supabase:", err);
					alert("L·ªói khi ƒë·∫©y data: " + err.message);
				}
			} else {
				alert("File kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng (C·∫ßn √≠t nh·∫•t h√†ng Ti√™u ƒë·ªÅ v√† h√†ng Group)");
			}
		};
		reader.readAsArrayBuffer(e.target.files[0]);
	});

	function initApp() {
		console.log("H√†m initApp ƒëang ch·∫°y...");
		if (rawData && rawData.length > 0) {
			document.getElementById('setup-screen').classList.add('hidden');
			document.getElementById('study-screen').classList.remove('hidden');
			updateDisplay();
		}
	}
    function switchMode(mode) {
        stopAutoPlay();
        currentMode = mode;
        if (mode === 'review') {
            prepareReviewPool();
            if (reviewPool.length === 0) { alert("Tr·ªëng!"); currentMode = 'study'; return; }
            document.getElementById('mode-title').innerText = "Ch·∫ø ƒë·ªô √¥n t·∫≠p";
            document.getElementById('study-controls').classList.add('hidden');
            document.getElementById('review-controls').classList.remove('hidden');
            document.getElementById('btn-to-review').classList.add('hidden');
            document.getElementById('btn-to-study').classList.remove('hidden');
            document.getElementById('random-multi-wrap').classList.remove('hidden');
            reviewIndex = 0; currentFieldIndex = 1; updateDisplay();
        } else {
            document.getElementById('mode-title').innerText = "Ch·∫ø ƒë·ªô h·ªçc t·∫≠p";
            document.getElementById('study-controls').classList.remove('hidden');
            document.getElementById('review-controls').classList.add('hidden');
            document.getElementById('btn-to-review').classList.remove('hidden');
            document.getElementById('btn-to-study').classList.add('hidden');
            document.getElementById('random-multi-wrap').classList.add('hidden');
            currentFieldIndex = 1; updateDisplay();
        }
    }

    function prepareReviewPool() {
        const learned = rawData.filter(w => stats[w[headers[0]]] === 'learned');
        const mastered = rawData.filter(w => stats[w[headers[0]]] === 'mastered');
        let pool = [];
        const isRandomMulti = document.getElementById('randomMulti').checked;
        if (isRandomMulti) {
            let tempMastered = [...mastered].sort(() => Math.random() - 0.5);
            let limitMastered = Math.max(1, Math.floor(learned.length * 0.05));
            pool = [...learned, ...tempMastered.slice(0, limitMastered)].sort(() => Math.random() - 0.5);
        } else {
            let processedSTT = new Set();
            let groupedPool = [];
            let validWords = [...learned, ...mastered].sort(() => Math.random() - 0.5);
            validWords.forEach(word => {
                let stt = String(word[headers[0]]);
                if (processedSTT.has(stt)) return;
                let match = stt.match(/^(\d+)([a-z])$/);
                if (match) {
                    let numPart = match[1];
                    let group = rawData.filter(w => String(w[headers[0]]).startsWith(numPart) && String(w[headers[0]]).match(/^\d+[a-z]$/)).sort((a, b) => String(a[headers[0]]).localeCompare(String(b[headers[0]])));
                    group.forEach(g => { groupedPool.push(g); processedSTT.add(String(g[headers[0]])); });
                } else { groupedPool.push(word); processedSTT.add(stt); }
            });
            pool = groupedPool;
        }
        reviewPool = pool;
    }

function updateDisplay() {
    if (!rawData.length) return;
    const card = document.getElementById('main-card');
    
    let word = currentMode === 'study' ? rawData[currentWordIndex] : reviewPool[reviewIndex];
    if (!word) return;

    // Hi·ªÉn th·ªã ‚≠ê/‚úÖ (Gi·ªØ nguy√™n)
    const statusDiv = document.getElementById('status-display');
    const wordKey = word[headers[0]];
    const currentStatus = stats[wordKey];
    statusDiv.innerHTML = (currentStatus === 'learned') ? '‚≠ê' : (currentStatus === 'mastered' ? '‚úÖ' : '');

    // 1. N·∫°p m·∫∑t tr∆∞·ªõc (Gi·ªØ nguy√™n)
    const frontHeader = headers[currentFieldIndex];
    document.getElementById('display-text').innerHTML = parseFurigana(word[frontHeader] || "");
    card.dataset.frontTitle = frontHeader;

    // 2. T√¨m m·∫∑t sau (Logic Grouping - Gi·ªØ nguy√™n)
    const currentMarker = String(groupMarkers[currentFieldIndex] || "");
    const backContent = document.getElementById('display-text-back');
    const hint = document.getElementById('flip-hint-text');
    
    backContent.innerHTML = "---";
    card.dataset.backTitle = ""; 

    if (currentMarker.includes('-F')) {
        const groupID = currentMarker.split('-')[0];
        const targetMarker = groupID + "-B";
        const partnerIdx = groupMarkers.findIndex(m => String(m).trim() === targetMarker);
        
        if (partnerIdx !== -1) {
            const partnerHeader = headers[partnerIdx];
            card.dataset.backTitle = partnerHeader;
            backContent.innerHTML = `<div style="font-size: 2rem;">${parseFurigana(word[partnerHeader])}</div>`;
            hint.innerText = "Ch·∫°m ƒë·ªÉ xem: " + partnerHeader;
            hint.classList.remove('hidden');
        } else {
            hint.classList.add('hidden');
        }
    } else {
        hint.classList.add('hidden');
    }

    // C·∫≠p nh·∫≠t thanh Nav (Gi·ªØ nguy√™n)
    if (!card.classList.contains('is-flipped')) {
        document.getElementById('curr-field').innerText = frontHeader;
    }
    
    const counterId = currentMode === 'study' ? 'word-counter' : 'review-counter';
    document.getElementById(counterId).innerText = `${word[headers[0]]} / ${rawData.length}`;

    // --- LOGIC ·∫®N/HI·ªÜN N√öT ƒêI·ªÄU H∆Ø·ªöNG THEO BI√äN (PH·∫¶N TH√äM M·ªöI) ---
    const btnLeft = document.querySelector('.arrow-left');
    const btnRight = document.querySelector('.arrow-right');

    if (btnLeft && btnRight) {
        // ·∫®n n√∫t tr√°i n·∫øu ƒëang ·ªü c·ªôt ƒë·∫ßu ti√™n (Index 1)
        if (currentFieldIndex <= 1) {
            btnLeft.style.display = 'none';
        } else {
            btnLeft.style.display = 'block';
        }

        // Ki·ªÉm tra n√∫t ph·∫£i: T√≠nh th·ª≠ b∆∞·ªõc ti·∫øp theo
        let nextIdx = currentFieldIndex;
        const m = String(groupMarkers[nextIdx] || "").trim();
        nextIdx += (m.includes('-F')) ? 2 : 1;
        // N·∫øu nh·∫£y tr√∫ng -B c·ªßa group ti·∫øp theo th√¨ nh·∫£y th√™m c√°i n·ªØa
        if (nextIdx < headers.length && String(groupMarkers[nextIdx] || "").includes('-B')) {
            nextIdx++;
        }

        // ·∫®n n√∫t ph·∫£i n·∫øu b∆∞·ªõc nh·∫£y ti·∫øp theo v∆∞·ª£t qu√° s·ªë c·ªôt
        if (nextIdx >= headers.length) {
            btnRight.style.display = 'none';
        } else {
            btnRight.style.display = 'block';
        }
    }

    // --- T·ª∞ ƒê·ªòNG ƒê·ªåC KHI CHUY·ªÇN C·ªòT / CHUY·ªÇN T·ª™ (Gi·ªØ nguy√™n) ---
    if (document.getElementById('autoSpeak').checked) {
        setTimeout(() => { speakText(); }, 300);
    }
}
	function moveWord(step) { 
        currentWordIndex = (currentWordIndex + step + rawData.length) % rawData.length; 
        currentFieldIndex = 1; 
		// Khi sang t·ª´ m·ªõi th√¨ m·ªõi reset v·ªÅ m·∫∑t tr∆∞·ªõc
		document.getElementById('main-card').classList.remove('is-flipped');
        updateDisplay(); 
        syncToCloud(); // L∆∞u l·∫°i v·ªã tr√≠ ƒëang xem
    }
    function nextReviewWord() { if (reviewIndex < reviewPool.length - 1) reviewIndex++; else { prepareReviewPool(); reviewIndex = 0; } currentFieldIndex = 1; updateDisplay(); }
    function prevReviewWord() { reviewIndex = (reviewIndex - 1 + reviewPool.length) % reviewPool.length; currentFieldIndex = 1; updateDisplay(); }

	async function setStatus(status) {
        let word = currentMode === 'study' ? rawData[currentWordIndex] : reviewPool[reviewIndex];
        if (!word) return;
        const wordKey = word[headers[0]];
        if (status === null) delete stats[wordKey]; else stats[wordKey] = status;
        
        // L∆∞u l√™n Cloud thay v√¨ localStorage
        await syncToCloud();

        if (currentMode === 'review' && (status === 'mastered' || status === null)) {
            reviewPool.splice(reviewIndex, 1);
            if (reviewPool.length === 0) { stopAutoPlay(); alert("Xong!"); switchMode('study'); return; }
            if (reviewIndex >= reviewPool.length) reviewIndex = 0;
            updateDisplay();
        } else { updateDisplay(); if(currentMode === 'review') nextReviewWord(); }
    }

	// S·ª≠a l·∫°i h√†m changeField ƒë·ªÉ ch·∫∑n s·ª± ki·ªán n·ªïi b·ªçt
function changeField(dir, e) {
    if (e) e.stopPropagation();
    
    // D·ª™NG ƒê·ªåC NGAY L·∫¨P T·ª®C ƒë·ªÉ gi·∫£i ph√≥ng h·ªá th·ªëng khi chuy·ªÉn c·ªôt
    if (window.speechSynthesis) {
        window.speechSynthesis.cancel();
    }
    
    let newIdx = currentFieldIndex;
    const marker = String(groupMarkers[newIdx] || "").trim();

    if (dir > 0) { // N√∫t TI·∫æN (>)
        // Logic: N·∫øu ƒëang ·ªü m·∫∑t tr∆∞·ªõc Group (-F) th√¨ nh·∫£y 2, n·∫øu kh√¥ng (c·ªôt ƒë∆°n/m·∫∑t sau) nh·∫£y 1
        newIdx += (marker.includes('-F')) ? 2 : 1;

        // N·∫øu v·ªã tr√≠ m·ªõi l·ªçt v√†o c·ªôt m·∫∑t sau (-B) c·ªßa group kh√°c, nh·∫£y th√™m 1 c√°i n·ªØa
        if (newIdx < headers.length && String(groupMarkers[newIdx] || "").includes('-B')) {
            newIdx++;
        }
    } else { // N√∫t L√ôI (<)
        newIdx -= 1;
        // N·∫øu l√πi tr√∫ng c·ªôt m·∫∑t sau (-B), l√πi th√™m ph√°t n·ªØa v·ªÅ m·∫∑t tr∆∞·ªõc (-F)
        if (newIdx >= 1 && String(groupMarkers[newIdx] || "").includes('-B')) {
            newIdx -= 1;
        }
    }

    // Ki·ªÉm tra gi·ªõi h·∫°n m·∫£ng
    if (newIdx >= 1 && newIdx < headers.length) {
        currentFieldIndex = newIdx;
        const card = document.getElementById('main-card');
        if (card) card.classList.remove('is-flipped'); 
        
        updateDisplay();
        return true;
    }
    return false;
}
	function handleSpeak(e) {
		if (e) e.stopPropagation();
		speakText();
	}
function handleCardClick(e) {
    // Kh√¥ng l·∫≠t n·∫øu b·∫•m tr√∫ng loa ho·∫∑c m≈©i t√™n
    if (e.target.closest('.speaker-icon') || e.target.closest('.nav-arrow')) return;
    
    const marker = String(groupMarkers[currentFieldIndex] || "");
    // Ch·ªâ cho l·∫≠t n·∫øu c·ªôt c√≥ ƒë√°nh d·∫•u -F ho·∫∑c -B
    if (marker.includes('-F') || marker.includes('-B')) {
        const card = document.getElementById('main-card');
        const navTitle = document.getElementById('curr-field');
        
        card.classList.toggle('is-flipped');
        
        // ƒê·ªïi ti√™u ƒë·ªÅ Nav d·ª±a tr√™n tr·∫°ng th√°i l·∫≠t
        if (card.classList.contains('is-flipped')) {
            navTitle.innerText = card.dataset.backTitle || card.dataset.frontTitle;
        } else {
            navTitle.innerText = card.dataset.frontTitle;
        }

        if (document.getElementById('autoSpeak').checked) {
            setTimeout(() => { speakText(); }, 250);
        }
    }
}
    /* FIX L·ªñI √ÇM THANH IPHONE TRI·ªÜT ƒê·ªÇ */
function speakText(callback) {
    const card = document.getElementById('main-card');
    const isFlipped = card?.classList.contains('is-flipped');
    const containerId = isFlipped ? 'display-text-back' : 'display-text';
    const originalElement = document.getElementById(containerId);
    
    if (!originalElement) { if (callback) callback(); return; }

    // --- CHI·∫æN THU·∫¨T X·ª¨ L√ù RUBY TRI·ªÜT ƒê·ªÇ ---
    // T·∫°o m·ªôt b·∫£n sao t·∫°m th·ªùi ƒë·ªÉ kh√¥ng l√†m h·ªèng giao di·ªán ƒëang hi·ªán
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = originalElement.innerHTML;
    
    // T√¨m t·∫•t c·∫£ c√°c th·∫ª <rt> (ph·∫ßn Furigana) v√† x√≥a s·∫°ch ch√∫ng
    const rts = tempDiv.querySelectorAll('rt');
    rts.forEach(rt => rt.remove());
    
    // L·∫•y text sau khi ƒë√£ x√≥a rt v√† x√≥a s·∫°ch c√°c d·∫•u ngo·∫∑c n·∫øu c√≥
    let cleanText = tempDiv.innerText.replace(/\([^)]+\)/g, "").replace(/\[[^\]]+\]/g, "").trim();

    if (cleanText === "N.A" || !cleanText || cleanText === "---") { 
        if (callback) callback(); 
        return; 
    }
    
    synth.cancel(); 
    const utter = new SpeechSynthesisUtterance(cleanText);
    
    // Gi·ªØ nguy√™n logic nh·∫≠n di·ªán ng√¥n ng·ªØ v√† ch·ªçn gi·ªçng c·ªßa b·∫°n
    const isJP = /[\u3040-\u30ff\u3400-\u4dbf\u4e00-\u9fff]/.test(cleanText);
    const isVN = /[√†-·ªπ]|[√Ä-·ª∏]/i.test(cleanText);
    let langCode = isJP ? 'ja-JP' : (isVN ? 'vi-VN' : 'en-US');
    utter.lang = langCode;

    let voices = synth.getVoices().filter(v => v.lang.includes(langCode.split('-')[0]));
    if (voices.length > 0) {
        let selectedVoice = isJP ? (voices.find(v => v.name.includes('Kyoko')) || voices[0]) :
                           (isVN ? (voices.find(v => v.name.includes('Linh')) || voices[0]) :
                           (voices.find(v => v.name.includes('Samantha')) || voices[0]));
        utter.voice = selectedVoice;
    }

    utter.rate = document.getElementById('voiceRate').value || 1;
    utter.onend = () => { if (callback) callback(); };
    utter.onerror = () => { if (callback) callback(); };
    
    setTimeout(() => { synth.speak(utter); }, 100);
}

    function toggleAutoPlay() { if (isAutoPlaying) stopAutoPlay(); else startAutoPlay(); }
    function startAutoPlay() { isAutoPlaying = true; document.getElementById('btn-autoplay').innerText = "‚èπ D·ª´ng ph√°t"; document.getElementById('btn-autoplay').style.background = "var(--danger)"; currentFieldIndex = 1; updateDisplay(); playSequence(); }
    function stopAutoPlay() { isAutoPlaying = false; synth.cancel(); document.getElementById('btn-autoplay').innerText = "‚ñ∂ T·ª± ƒë·ªông ph√°t"; document.getElementById('btn-autoplay').style.background = "#8b5cf6"; }

    function playSequence() {
        if (!isAutoPlaying) return;
        
        // ƒê·ªçc t√™n c·ªôt (Vi·ªát)
        const headerText = headers[currentFieldIndex];
        const utterHeader = new SpeechSynthesisUtterance(headerText);
        utterHeader.lang = 'vi-VN';
        
        if (availableVoices.length > 0) {
            const viVoice = availableVoices.find(v => v.lang.startsWith('vi-VN'));
            if (viVoice) utterHeader.voice = viVoice;
        }

        utterHeader.rate = document.getElementById('voiceRate').value;
        utterHeader.onend = () => {
            if (!isAutoPlaying) return;
            // ƒê·ªçc n·ªôi dung √¥
            speakText(() => {
                if (!isAutoPlaying) return;
                setTimeout(() => {
                    if (!isAutoPlaying) return;
                    if (currentFieldIndex < headers.length - 1) { 
                        currentFieldIndex++; 
                        updateDisplay(); 
                        playSequence(); 
                    } else { 
                        if (reviewIndex < reviewPool.length - 1) { 
                            reviewIndex++; 
                            currentFieldIndex = 1; 
                            updateDisplay(); 
                            playSequence(); 
                        } else { stopAutoPlay(); } 
                    }
                }, 800);
            });
        };
        synth.speak(utterHeader);
    }

    function showQuizScreen() {
        stopAutoPlay();
        document.getElementById('study-screen').classList.add('hidden');
        document.getElementById('quiz-screen').classList.remove('hidden');
        document.getElementById('quiz-setup').classList.remove('hidden');
        document.getElementById('quiz-playing').classList.add('hidden');
        const pool = rawData.filter(w => stats[w[headers[0]]]);
        document.getElementById('quiz-header-title').innerText = `üìù Tr·∫Øc nghi·ªám (${pool.length})`;
        if (scenarios.length === 0) { scenarios.push({ root: headers[1], exclude: [headers[0]] }); saveScenarios(); }
        renderScenarios();
    }

    function addScenario() { scenarios.push({ root: headers[1], exclude: [headers[0]] }); saveScenarios(); renderScenarios(); }
    function removeScenario(idx) { scenarios.splice(idx, 1); if (scenarios.length === 0) addScenario(); else { saveScenarios(); renderScenarios(); } }
    function saveScenarios() { localStorage.setItem('quiz_scenarios', JSON.stringify(scenarios)); }

	function renderScenarios() {
		const list = document.getElementById('scenarios-list');
		list.innerHTML = "";
		const poolCount = rawData.filter(w => stats[w[headers[0]]] === 'learned' || stats[w[headers[0]]] === 'mastered').length;
	
		scenarios.forEach((sc, idx) => {
			const box = document.createElement('div');
			box.className = 'scenario-box';
			let rootOpts = headers.slice(1).map(h => `<option value="${h}" ${h === sc.root ? 'selected' : ''}>${h}</option>`).join('');
			let exOpts = headers.slice(1).filter(h => h !== sc.root).map(h => `<label class="exclude-item"><input type="checkbox" ${sc.exclude.includes(h) ? 'checked' : ''} onchange="toggleExclude(${idx}, '${h}')"> ${h}</label>`).join('');
			const targetCount = headers.filter((h, i) => i !== 0 && h !== sc.root && !sc.exclude.includes(h)).length;
			const maxPossible = poolCount * targetCount;
	
			box.innerHTML = `
				<span class="remove-scenario" onclick="removeScenario(${idx})">‚úñ X√≥a</span>
				<span class="scenario-title">K·ªãch b·∫£n ${idx+1}</span>
				<div style="font-size: 0.8rem; color: var(--primary); margin-bottom: 10px;">
					T·ªëi ƒëa: <strong>${maxPossible}</strong> c√¢u h·ªèi
				</div>
				<div class="select-group">
					<label>C·ªôt g·ªëc:</label>
					<select onchange="updateRoot(${idx}, this.value)" style="width:100%; padding:5px; border-radius:5px;">${rootOpts}</select>
				</div>
				<div class="select-group">
					<label>C·ªôt lo·∫°i tr·ª´:</label>
					<div class="exclude-list">${exOpts}</div>
				</div>`;
			list.appendChild(box);
		});
	}

    function updateRoot(idx, val) { scenarios[idx].root = val; saveScenarios(); renderScenarios(); }
    function toggleExclude(idx, val) {
        const i = scenarios[idx].exclude.indexOf(val);
        if (i > -1) scenarios[idx].exclude.splice(i, 1); else scenarios[idx].exclude.push(val);
        saveScenarios(); renderScenarios();
    }

    function startQuiz() {
        const Q = parseInt(document.getElementById('quizCount').value) || null;
        const timeVal = parseInt(document.getElementById('timePerQuestion').value) || 10;
        const pool = rawData.filter(w => stats[w[headers[0]]]);
        if (!pool.length) { alert("H·ªçc th√™m t·ª´ ƒëi!"); return; }
        quizData = []; userAnswers = {};
        scenarios.forEach(sc => {
            const targets = headers.filter((h, i) => i !== 0 && h !== sc.root && !sc.exclude.includes(h));
            pool.forEach(word => { targets.forEach(t => { quizData.push({ rH: sc.root, tH: t, rV: word[sc.root], cV: word[t] }); }); });
        });
        quizData.sort(() => Math.random() - 0.5);
        if (Q && Q < quizData.length) quizData = quizData.slice(0, Q);
        document.getElementById('quiz-setup').classList.add('hidden');
        document.getElementById('quiz-playing').classList.remove('hidden');
        document.getElementById('quiz-result-summary').classList.add('hidden');
        document.getElementById('quiz-finish-btn').classList.remove('hidden');
        const container = document.getElementById('quiz-container');
        container.innerHTML = "";
        quizData.forEach((q, idx) => {
            const item = document.createElement('div'); item.className = 'quiz-item'; item.id = `quiz-q-${idx}`;
            let allVals = [...new Set(rawData.map(w => w[q.tH]))];
            let choices = [q.cV, ...allVals.filter(v => v !== q.cV).sort(() => Math.random() - 0.5).slice(0, 3)].sort(() => Math.random() - 0.5);
            item.innerHTML = `<h4>C√¢u ${idx+1}: "${q.tH}" c·ªßa <u>${q.rV}</u>?</h4>`;
            choices.forEach(c => {
                const b = document.createElement('button'); b.className = 'option-btn'; b.innerText = c;
                b.onclick = () => {
                    if (document.getElementById('quiz-finish-btn').classList.contains('hidden')) return;
                    Array.from(item.querySelectorAll('.option-btn')).forEach(btn => btn.classList.remove('selected'));
                    b.classList.add('selected'); userAnswers[idx] = c;
                };
                item.appendChild(b);
            });
            container.appendChild(item);
        });
        let timeLeft = quizData.length * timeVal;
        clearInterval(quizInterval);
        quizInterval = setInterval(() => {
            timeLeft--;
            let m = Math.floor(timeLeft / 60), s = timeLeft % 60;
            document.getElementById('time-left').innerText = `${m}:${s < 10 ? '0' : ''}${s}`;
            if (timeLeft <= 0) { clearInterval(quizInterval); finishQuiz(); }
        }, 1000);
    }

    function finishQuiz() {
        clearInterval(quizInterval);
        document.getElementById('quiz-finish-btn').classList.add('hidden');
        const summary = document.getElementById('quiz-result-summary');
        summary.classList.remove('hidden');
        let score = 0;
        quizData.forEach((q, idx) => {
            const item = document.getElementById(`quiz-q-${idx}`);
            item.querySelectorAll('.option-btn').forEach(b => {
                b.style.pointerEvents = 'none';
                if (b.innerText === q.cV) b.classList.add('correct-ans');
                if (userAnswers[idx] === b.innerText && b.innerText !== q.cV) b.classList.add('wrong-ans');
            });
            if (userAnswers[idx] === q.cV) score++;
        });
        summary.innerHTML = `<h3 style="margin-top:0">K·∫øt qu·∫£: ${score}/${quizData.length}</h3>`;
        quizData.forEach((_, i) => {
            const dot = document.createElement('span'); dot.className = 'dot-nav';
            dot.style.background = (userAnswers[i] === quizData[i].cV) ? 'var(--success)' : 'var(--danger)';
            dot.innerText = i + 1;
            dot.onclick = () => document.getElementById(`quiz-q-${i}`).scrollIntoView({ behavior: 'smooth' });
            summary.appendChild(dot);
        });
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }

    function exitQuiz() { clearInterval(quizInterval); document.getElementById('quiz-screen').classList.add('hidden'); document.getElementById('study-screen').classList.remove('hidden'); }
    async function resetDatabase() {
    if (confirm("B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën X√ìA S·∫†CH d·ªØ li·ªáu tr√™n Cloud kh√¥ng? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c!")) {
        try {
            // 1. X√≥a to√†n b·ªô t·ª´ v·ª±ng trong b·∫£ng hoc_tap
            const { error: err1 } = await supabaseClient.from('hoc_tap').delete().neq('row_index', -1);
            
            // 2. Reset ti·∫øn ƒë·ªô v√† ti√™u ƒë·ªÅ trong b·∫£ng user_progress
            const { error: err2 } = await supabaseClient.from('user_progress').upsert({
                id: 'current_user',
                stats: {},
                headers: [],
                current_index: 0
            });

            if (err1 || err2) throw new Error("L·ªói khi x√≥a d·ªØ li·ªáu tr√™n Cloud");

            // 3. X√≥a n·ªët localStorage cho s·∫°ch m√°y
            localStorage.clear();
            
            alert("ƒê√£ x√≥a s·∫°ch d·ªØ li·ªáu tr√™n Cloud! Trang web s·∫Ω t·∫£i l·∫°i.");
            location.reload();
        } catch (err) {
            console.error(err);
            alert("C√≥ l·ªói x·∫£y ra: " + err.message);
        }
    }
}
</script>
</body>
</html>