<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Study Tool - Master Linker</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf_viewer.min.css">
    <style>
        :root { --primary: #2563eb; --bg: #e2e8f0; --sidebar-w: 380px; }
        body { font-family: -apple-system, sans-serif; margin: 0; background: var(--bg); display: flex; height: 100vh; overflow: hidden; }
        #main-content { flex: 1; display: flex; flex-direction: column; height: 100vh; position: relative; }
        #toolbar { background: #1e293b; color: white; padding: 12px 25px; display: flex; gap: 15px; align-items: center; z-index: 100; }
        .btn-tool { background: var(--primary); color: white; padding: 8px 15px; border-radius: 6px; cursor: pointer; border: none; font-weight: bold; font-size: 13px; }
        .btn-tool.secondary { background: #475569; }
        #viewer-container { flex: 1; overflow: auto; padding: 20px; display: flex; flex-direction: column; align-items: center; }
        .page-container { position: relative; background: white; margin-bottom: 30px; box-shadow: 0 10px 25px rgba(0,0,0,0.2); }
        .textLayer { opacity: 1;} 
        .hl-box { position: absolute; background: rgba(255, 255, 0, 0.4); cursor: pointer; z-index: 1; }
        .ul-box { position: absolute; border-bottom: 2px solid red; cursor: pointer; z-index: 1; }
        .nt-box { position: absolute; cursor: pointer; z-index: 10; font-size: 12px; transform: translate(-50%, -50%); transition: transform 0.2s; }
        .nt-box:hover { transform: translate(-50%, -50%) scale(1.3); }
        #info-sidebar { width: var(--sidebar-w); background: white; border-left: 1px solid #cbd5e1; display: flex; flex-direction: column; box-shadow: -5px 0 15px rgba(0,0,0,0.05); transform: translateX(100%); transition: 0.3s; position: absolute; right: 0; top: 0; bottom: 0; z-index: 1000; }
        #info-sidebar.open { transform: translateX(0); }
        .sidebar-header { background: #f8fafc; padding: 15px; border-bottom: 1px solid #e2e8f0; font-weight: bold; display: flex; justify-content: space-between; }
        .sidebar-content { padding: 20px; overflow-y: auto; flex: 1; line-height: 1.6; }
        .info-label { color: #64748b; font-size: 11px; font-weight: bold; text-transform: uppercase; margin-top: 15px; display: block; }
        .info-value { background: #f1f5f9; padding: 10px; border-radius: 4px; display: block; margin-bottom: 10px; border-left: 4px solid var(--primary); font-size: 14px; }
        .textLayer span {
    white-space: pre;
}

::selection {
    background: rgba(255, 200, 0, 0.6);
}

        /* New Styles for Linking */
        .grammar-row { margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px solid #eee; }
        .link-status { font-size: 10px; padding: 2px 6px; border-radius: 10px; cursor: pointer; margin-left: 5px; }
        .status-none { background: #fee2e2; color: #dc2626; border: 1px solid #fecaca; }
        .status-linked { background: #dcfce7; color: #16a34a; border: 1px solid #bbf7d0; }
        .quote-text { font-weight: bold; cursor: pointer; color: var(--primary); }
        .master-data-box { background: white; border: 1px solid #2563eb; padding: 10px; border-radius: 5px; margin-top: 8px; display: none; font-size: 13px; }
        .master-data-box.open { display: block; }

        /* Search Modal */
        #search-modal { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 4000; align-items: center; justify-content: center; }
        .search-box { background: white; width: 400px; padding: 20px; border-radius: 10px; max-height: 80vh; display: flex; flex-direction: column; }
        .search-results { overflow-y: auto; margin-top: 10px; }
        .result-item { padding: 10px; border-bottom: 1px solid #eee; cursor: pointer; }
        .result-item:hover { background: #f1f5f9; }

        #floating-menu { display: none; position: fixed; background: white; border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); z-index: 2000; padding: 5px; border: 1px solid #ccc; }
        #floating-menu button { border: none; background: none; padding: 10px 15px; cursor: pointer; font-weight: bold; border-radius: 4px; }
        #note-form-overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 3000; align-items: center; justify-content: center; }
        .note-form { background: white; padding: 25px; border-radius: 12px; width: 500px; display: flex; flex-direction: column; gap: 10px; }
        .note-form textarea { width: 100%; height: 80px; padding: 8px; border: 1px solid #ccc; border-radius: 4px; font-family: inherit; }
		/* === Kindle-like selection stability === */
.textLayer span,
.textLayer div {
    display: inline-block;
    white-space: pre;
    pointer-events: auto;
}

/* Kh√¥ng cho leader dots + page number b·ªã select */
.textLayer span.no-select {
    user-select: none;
}
#info-sidebar {
    visibility: hidden;
}
#info-sidebar.open {
    visibility: visible;
}
.textLayer {
    -webkit-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;
}

    </style>
</head>
<body>

<div id="main-content">
    <div id="toolbar">
        <label class="btn-tool">üìÇ M·ªü PDF <input type="file" id="file-selector" accept="application/pdf" style="display:none"></label>
        <label class="btn-tool secondary">üìñ N·∫°p Master <input type="file" id="master-loader" accept=".json" style="display:none"></label>
        <label class="btn-tool secondary">ü§ñ Auto Mapping <input type="file" id="mapping-selector" accept=".json" style="display:none"></label>
        <label class="btn-tool" style="background: #059669;">üì• Import Notes <input type="file" id="import-selector" accept=".json" style="display:none"></label>
        <button class="btn-tool secondary" onclick="exportNotes()">üíæ Xu·∫•t JSON</button>
        <div id="status" style="font-size: 12px; color: #cbd5e1;">N·∫°p PDF -> Master -> Mapping/Import.</div>
    </div>
    <div id="viewer-container"></div>
</div>

<div id="info-sidebar">
    <div class="sidebar-header">CHI TI·∫æT PH√ÇN T√çCH <button onclick="closeSidebar()" style="cursor:pointer; border:none; background:none">‚úñ</button></div>
    <div class="sidebar-content" id="sidebar-data"></div>
    <div style="padding:15px; border-top:1px solid #eee">
        <button id="del-btn" style="color:red; cursor:pointer; border:none; background:none">üóë X√≥a ghi ch√∫ n√†y</button>
    </div>
</div>

<div id="search-modal">
    <div class="search-box">
        <h3>T√¨m trong Master Dictionary</h3>
        <input type="text" id="master-search-input" placeholder="G√µ t·ª´ kh√≥a..." style="padding:10px; border:1px solid #ccc">
        <div class="search-results" id="master-results"></div>
        <button onclick="document.getElementById('search-modal').style.display='none'" style="margin-top:10px">ƒê√≥ng</button>
    </div>
</div>

<div id="note-form-overlay">
    <div class="note-form">
        <h3>G√°n th√¥ng tin ph√¢n t√≠ch</h3>
        <span class="info-label">C√¢u g·ªëc (Source)</span>
        <div id="form-source" style="font-weight:bold; background:#eee; padding:10px; max-height: 60px; overflow: auto;"></div>
        <span class="info-label">D·ªãch (Translation)</span>
        <textarea id="form-trans"></textarea>
        <span class="info-label">Ng·ªØ ph√°p (Grammar)</span>
        <textarea id="form-grammar" placeholder="{Tr√≠ch}:{Nghƒ©a}"></textarea>
        <span class="info-label">Th√†nh ph·∫ßn (Components)</span>
        <textarea id="form-comp" placeholder="{Tr√≠ch}:{Nghƒ©a}"></textarea>
        <div style="display:flex; justify-content: flex-end; gap: 10px; margin-top: 10px;">
            <button onclick="closeForm()">H·ªßy</button>
            <button onclick="saveNote()" style="background:var(--primary); color:white; border:none; padding:10px 20px; border-radius:4px; cursor:pointer">L∆∞u l·∫°i</button>
        </div>
    </div>
</div>

<div id="floating-menu">
    <button onclick="addMarkup('hl')">üñç HL</button>
    <button onclick="addMarkup('ul')"><u>U</u></button>
    <button onclick="showNoteForm()">üìù Note</button>
</div>

<script>
    const pdfjsLib = window['pdfjs-dist/build/pdf'];
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

    const viewer = document.getElementById('viewer-container');
    const menu = document.getElementById('floating-menu');
    const sidebar = document.getElementById('info-sidebar');
    let selectedRange = null;
    let allNotes = [];
    let masterData = [];
    let currentLinkTarget = null;
	let userHasInteracted = false;
	let touchSelecting = false;
let touchStart = null;
let iosSelection = {
    pageNode: null,
    rects: [],
    text: ""
};

viewer.addEventListener('touchstart', e => {
    if (e.touches.length !== 1) return;
    touchStart = {
        x: e.touches[0].clientX,
        y: e.touches[0].clientY,
        time: Date.now()
    };
});

viewer.addEventListener('touchmove', e => {
    if (!touchStart) return;
    if (Date.now() - touchStart.time < 300) return;

    touchSelecting = true;
    e.preventDefault(); // ‚õî ch·∫∑n scroll + copy

// clear overlay c≈©
document.querySelectorAll('.ios-select-box').forEach(el => el.remove());

const t = e.touches[0];
const endEl = document.elementFromPoint(t.clientX, t.clientY);
if (!endEl) return;

const pageNode = endEl.closest('.page-container');
if (!pageNode) return;

iosSelection.pageNode = pageNode;

const textLayer = pageNode.querySelector('.textLayer');
const spans = [...textLayer.querySelectorAll('span, div')];

const selRect = {
    left: Math.min(touchStart.x, t.clientX),
    right: Math.max(touchStart.x, t.clientX),
    top: Math.min(touchStart.y, t.clientY),
    bottom: Math.max(touchStart.y, t.clientY)
};

iosSelection.rects = [];

spans.forEach(span => {
    if (!span.__charRects) return;

    span.__charRects.forEach(c => {
        const overlap =
            !(c.right < selRect.left || c.left > selRect.right ||
              c.bottom < selRect.top || c.top > selRect.bottom);

        if (overlap) {
            iosSelection.rects.push(c);

            const box = document.createElement('div');
            box.className = 'hl-box ios-select-box';
            box.style.left = (c.left - pageNode.getBoundingClientRect().left) + 'px';
            box.style.top  = (c.top  - pageNode.getBoundingClientRect().top ) + 'px';
            box.style.width  = (c.right - c.left) + 'px';
            box.style.height = (c.bottom - c.top) + 'px';
            pageNode.appendChild(box);
        }
    });
});


});

viewer.addEventListener('touchend', e => {
    if (!touchSelecting) {
        touchStart = null;
        return;
    }

iosSelection.text = extractTextByRects({
    getClientRects: () => iosSelection.rects,
    startContainer: iosSelection.pageNode.querySelector('.textLayer')
});

selectedRange = null; // ‚õî √©p iOS kh√¥ng d√πng native range

    menu.style.display = 'flex';
    menu.style.left = touchStart.x + 'px';
    menu.style.top = (touchStart.y - 50) + 'px';

    touchSelecting = false;
    touchStart = null;
});


['touchstart', 'mousedown', 'keydown'].forEach(evt => {
    document.addEventListener(evt, () => {
        userHasInteracted = true;
    }, { once: true });
});
const _showDetails = showDetails;
showDetails = function(note, pinElement) {
    if (!userHasInteracted) return; // ‚õî ch·∫∑n Safari auto-trigger
    _showDetails(note, pinElement);
};

    // N·∫°p file master.json
    document.getElementById('master-loader').onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
            masterData = JSON.parse(ev.target.result);
            document.getElementById('status').innerText = `ƒê√£ n·∫°p ${masterData.length} m·ª•c t·ª´ ƒëi·ªÉn.`;
        };
        reader.readAsText(file);
    };

    // M·ªü File PDF
    document.getElementById('file-selector').onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        viewer.innerHTML = 'ƒêang t·∫£i PDF...';
        const pdf = await pdfjsLib.getDocument({ data: await file.arrayBuffer() }).promise;
        viewer.innerHTML = '';
        for (let i = 1; i <= pdf.numPages; i++) {
            const page = await pdf.getPage(i);
            const viewport = page.getViewport({ scale: 1.5 });
            const pageDiv = document.createElement('div');
            pageDiv.className = 'page-container';
            pageDiv.id = 'page-' + i;
            pageDiv.style.width = viewport.width + 'px';
            pageDiv.style.height = viewport.height + 'px';
            viewer.appendChild(pageDiv);
            const canvas = document.createElement('canvas');
            canvas.width = viewport.width; canvas.height = viewport.height;
            pageDiv.appendChild(canvas);
            await page.render({ canvasContext: canvas.getContext('2d'), viewport }).promise;
            const textLayerDiv = document.createElement('div');
            textLayerDiv.className = 'textLayer';
            pageDiv.appendChild(textLayerDiv);
            await pdfjsLib.renderTextLayer({ textContent: await page.getTextContent(), container: textLayerDiv, viewport, textDivs: [] }).promise;
			textLayerDiv.querySelectorAll('span').forEach(span => {
    const text = span.innerText;
    if (!text || span.classList.contains('no-select')) return;

    const r = span.getBoundingClientRect();
    const p = span.closest('.page-container').getBoundingClientRect();
    const charW = r.width / text.length;

    span.__charRects = [...text].map((ch, i) => ({
        char: ch,
        left: r.left + i * charW,
        right: r.left + (i + 1) * charW,
        top: r.top,
        bottom: r.bottom
    }));
});

			// Kindle-style: disable selection for leader dots / page numbers
textLayerDiv.querySelectorAll('span').forEach(span => {
    const t = span.innerText || "";
    if (/^[\.\s\d]{8,}$/.test(t)) {
        span.classList.add('no-select');
    }
});

        }
        document.getElementById('status').innerText = "PDF ƒë√£ s·∫µn s√†ng.";
    };

    // --- CH·ª®C NƒÇNG IMPORT NOTES (D√ôNG L·∫†I D·ªÆ LI·ªÜU ƒê√É XU·∫§T) ---
    document.getElementById('import-selector').onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
            const imported = JSON.parse(ev.target.result);
            allNotes = imported; // Ghi ƒë√® ho·∫∑c n·ªëi th√™m t√πy √Ω, ·ªü ƒë√¢y t√¥i ch·ªçn thay th·∫ø
            // X√≥a h·∫øt pin c≈© tr√™n m√†n h√¨nh tr∆∞·ªõc khi v·∫Ω m·ªõi
            document.querySelectorAll('.nt-box').forEach(el => el.remove());
            allNotes.forEach(note => createPin(note));
            alert(`ƒê√£ n·∫°p th√†nh c√¥ng ${allNotes.length} ghi ch√∫ t·ª´ file.`);
        };
        reader.readAsText(file);
    };

    // --- CH·ª®C NƒÇNG AUTO MAPPING ---
    document.getElementById('mapping-selector').onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = async (ev) => {
            const data = JSON.parse(ev.target.result);
            let count = 0;
            for (let item of data) {
                let cleanSource = item.SOURCE.replace(/<rt>.*?<\/rt>/g, "").replace(/<[^>]*>/g, "").trim();
                const success = await findAndPin(cleanSource, item);
                if (success) count++;
            }
            alert(`Ho√†n t·∫•t Auto Mapping! ${count}/${data.length} c√¢u.`);
        };
        reader.readAsText(file);
    };

async function findAndPin(cleanText, rawData) {
    const pages = document.querySelectorAll('.page-container');
    const searchString = cleanText.toLowerCase().replace(/\s+/g, '');
    for (let page of pages) {
        const textLayer = page.querySelector('.textLayer');
        if (!textLayer) continue;
        const allDivs = Array.from(textLayer.querySelectorAll('div, span'));
        let fullPageText = "";
        let charMap = []; 
        allDivs.forEach(div => {
            const originalText = div.innerText;
            const rect = div.getBoundingClientRect();
            const pRect = page.getBoundingClientRect();
            const charWidth = rect.width / (originalText.length || 1);
            for (let i = 0; i < originalText.length; i++) {
                const char = originalText[i].toLowerCase();
                if (/\S/.test(char)) {
                    fullPageText += char;
                    charMap.push({
                        x: ((rect.left - pRect.left + (i * charWidth)) / pRect.width) * 100,
                        y: ((rect.top - pRect.top) / pRect.height) * 100,
                        el: div
                    });
                }
            }
        });
        const matchIdx = fullPageText.indexOf(searchString);
        if (matchIdx !== -1) {
            const firstCharData = charMap[matchIdx];
            const targetEl = firstCharData.el;
            targetEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            const originalBg = targetEl.style.background;
            targetEl.style.background = "#fbbf24";
            const userConfirmed = await new Promise((resolve) => {
                setTimeout(() => {
                    const ok = confirm(`Kh·ªõp: "${cleanText.substring(0, 30)}..."\nC·∫Øm ghim?`);
                    resolve(ok);
                }, 500);
            });
            targetEl.style.background = originalBg;
            if (userConfirmed) {
                const note = {
                    id: Date.now() + Math.random(),
                    pageId: page.id,
                    source: rawData.SOURCE,
                    trans: rawData.TRANSLATION,
                    grammar: rawData.GRAMMAR,
                    comp: rawData.COMPONENTS,
                    x: firstCharData.x, 
                    y: firstCharData.y
                };
                allNotes.push(note);
                createPin(note);
                return true;
            }
        }
    }
    return false;
}
function extractTextByRects(range) {
    const rects = Array.from(range.getClientRects());
    if (!rects.length) return "";

    const pageNode = range.startContainer.parentElement.closest('.page-container');
    if (!pageNode) return "";

    const textLayer = pageNode.querySelector('.textLayer');
    const spans = Array.from(textLayer.querySelectorAll('span, div'));

    const hits = [];

    rects.forEach(r => {
        spans.forEach(span => {
            if (span.classList.contains('no-select')) return;

            const b = span.getBoundingClientRect();
            const overlap =
                !(b.right < r.left || b.left > r.right || b.bottom < r.top || b.top > r.bottom);

            if (overlap) {
                hits.push({
                    text: span.innerText,
                    top: b.top,
                    left: b.left
                });
            }
        });
    });

    // sort theo v·ªã tr√≠ v·∫≠t l√Ω: tr√™n ‚Üí d∆∞·ªõi, tr√°i ‚Üí ph·∫£i
    hits.sort((a, b) =>
        Math.abs(a.top - b.top) > 5 ? a.top - b.top : a.left - b.left
    );

    // clean + merge
    return hits
		.map(h => h.char || h.text)
		.join('')
		.replace(/\s+/g, ' ')
		.trim();

}

function mergeRectsByLine(rects) {
    const lines = [];
    const tolerance = 5; // px ‚Äì cho PDF scale kh√°c nhau

    for (let r of rects) {
        let line = lines.find(l =>
            Math.abs(l.centerY - (r.top + r.height / 2)) < tolerance
        );

        if (!line) {
            lines.push({
                top: r.top,
                bottom: r.bottom,
                left: r.left,
                right: r.right,
                centerY: r.top + r.height / 2
            });
        } else {
            line.left = Math.min(line.left, r.left);
            line.right = Math.max(line.right, r.right);
            line.top = Math.min(line.top, r.top);
            line.bottom = Math.max(line.bottom, r.bottom);
        }
    }

    return lines.map(l => ({
        top: l.top,
        height: l.bottom - l.top
    }));
}


    // --- LOGIC PH√ÇN T√çCH CHU·ªñI V√Ä LINKING ---
    function renderParsedContent(note, fieldName) {
        const text = note[fieldName];
        if (!text) return "N/A";
        const lines = text.split('\n');
        let html = "";
        lines.forEach((line, index) => {
            const matches = [...line.matchAll(/\{(.*?)\}/g)].map(m => m[1]);
            if (matches.length >= 2) {
                const quote = matches[0];
                const desc = matches[1];
                const masterIds = matches[2] ? matches[2].split(',').map(id => id.trim()).filter(id => id) : [];
                const isLinked = masterIds.length > 0;
                const uniqueBoxId = `box-${fieldName}-${note.id.toString().replace('.','')}-${index}`;

                html += `<div class="grammar-row">
                    <span class="quote-text" onclick="toggleMasterBox('${uniqueBoxId}')">${quote}</span>: ${desc}
                    <span class="link-status ${isLinked?'status-linked':'status-none'}" 
                          onclick="openLinkSearch('${note.id}', '${fieldName}', ${index})">
                        ${isLinked ? 'Linked ('+masterIds.length+')' : 'no link'}
                    </span>
                    <div id="${uniqueBoxId}" class="master-data-box">
                        ${isLinked ? renderMasterInfo(masterIds) : '<i>Ch∆∞a g√°n link d·ªØ li·ªáu.</i>'}
                    </div>
                </div>`;
            } else {
                html += `<div>${line}</div>`;
            }
        });
        return html;
    }

    function renderMasterInfo(ids) {
        let h = "";
        ids.forEach(id => {
            const data = masterData.find(m => m.master_id === id);
            if (data) {
                h += `<div style="border-bottom:1px dashed #ccc; margin-bottom:5px; padding-bottom:5px">
                    <b style="color:red">${data.pattern}</b> (${data.reading})<br>
                    <span style="font-weight:bold">${data.core_meaning}</span><br>
                    <small>${data.description}</small>
                </div>`;
            } else h += `<div style="color:red">ID kh√¥ng kh·ªõp Master: ${id}</div>`;
        });
        return h;
    }

    function toggleMasterBox(id) {
        const el = document.getElementById(id);
        if(el) el.classList.toggle('open');
    }

    function openLinkSearch(noteId, field, lineIdx) {
        if(masterData.length === 0) return alert("C·∫ßn n·∫°p Master.json tr∆∞·ªõc!");
        currentLinkTarget = { noteId, field, lineIdx };
        document.getElementById('search-modal').style.display = 'flex';
        document.getElementById('master-results').innerHTML = "";
    }

    document.getElementById('master-search-input').oninput = (e) => {
        const key = e.target.value.toLowerCase();
        if(!key) return;
        const results = masterData.filter(m => 
            m.pattern.toLowerCase().includes(key) || 
            m.core_meaning.toLowerCase().includes(key) ||
            m.master_id.toLowerCase().includes(key)
        ).slice(0, 10);
        let h = "";
        results.forEach(r => {
            h += `<div class="result-item" onclick="attachMasterId('${r.master_id}')">
                <b>${r.pattern}</b> - ${r.core_meaning} <br> <small>${r.master_id}</small>
            </div>`;
        });
        document.getElementById('master-results').innerHTML = h;
    };

    function attachMasterId(mId) {
        const note = allNotes.find(n => n.id.toString() == currentLinkTarget.noteId.toString());
        const lines = note[currentLinkTarget.field].split('\n');
        let line = lines[currentLinkTarget.lineIdx];
        const matches = [...line.matchAll(/\{(.*?)\}/g)].map(m => m[1]);
        
        if(matches.length == 2) {
            line = `{${matches[0]}}:{${matches[1]}}:{${mId}}`;
        } else if(matches.length >= 3) {
            const existingIds = matches[2].split(',').map(i => i.trim()).filter(i => i);
            if(!existingIds.includes(mId)) existingIds.push(mId);
            line = `{${matches[0]}}:{${matches[1]}}:{${existingIds.join(', ')}}`;
        }
        lines[currentLinkTarget.lineIdx] = line;
        note[currentLinkTarget.field] = lines.join('\n');
        document.getElementById('search-modal').style.display = 'none';
        showDetails(note, null);
    }

    function createPin(note) {
        const parent = document.getElementById(note.pageId);
        if (!parent) return;
        const pin = document.createElement('div');
        pin.className = 'nt-box'; pin.innerHTML = 'üìå';
        pin.style.left = note.x + '%'; pin.style.top = note.y + '%';
        pin.onclick = (e) => { e.stopPropagation(); showDetails(note, pin); };
        parent.appendChild(pin);
    }

    function saveNote() {
        const r = selectedRange.getBoundingClientRect();
		const sourceText = selectedRange
			? extractTextByRects(selectedRange)
			: iosSelection.text;
        const pageNode = selectedRange.startContainer.parentElement.closest('.page-container');
        const pRect = pageNode.getBoundingClientRect();
        const note = {
            id: Date.now() + Math.random(),
            pageId: pageNode.id,
            source: extractTextByRects(selectedRange),
            trans: document.getElementById('form-trans').value,
            grammar: document.getElementById('form-grammar').value,
            comp: document.getElementById('form-comp').value,
            x: ((r.left - pRect.left + (r.width/2)) / pRect.width) * 100,
            y: ((r.top - pRect.top) / pRect.height) * 100
        };
        allNotes.push(note);
        createPin(note);
        closeForm();
        clearSelection();
    }

    function showDetails(note, pinElement) {
        const container = document.getElementById('sidebar-data');
        container.innerHTML = `
            <span class="info-label">Nguy√™n vƒÉn</span><div class="info-value" style="background:#fff">${note.source}</div>
            <span class="info-label">D·ªãch nghƒ©a</span><div class="info-value">${note.trans.replace(/\n/g, '<br>')}</div>
            <span class="info-label">Ng·ªØ ph√°p</span>
            <div class="info-value" style="background:white">${renderParsedContent(note, 'grammar')}</div>
            <span class="info-label">Th√†nh ph·∫ßn</span>
            <div class="info-value" style="background:white">${renderParsedContent(note, 'comp')}</div>
        `;
        sidebar.classList.add('open');
        if (pinElement) {
            document.getElementById('del-btn').onclick = () => {
                if(confirm("X√≥a ghi ch√∫ n√†y?")) {
                    allNotes = allNotes.filter(n => n.id !== note.id);
                    pinElement.remove(); closeSidebar();
                }
            };
        }
    }

function addMarkup(type) {
    if (!selectedRange && iosSelection.rects.length === 0) return;

    const rawRects = Array.from(selectedRange.getClientRects());
    if (!rawRects.length) return;

    const lines = mergeRectsByLine(rawRects);
    const pageNode = selectedRange.startContainer.parentElement.closest('.page-container');
    if (!pageNode) return;

    const pageRect = pageNode.getBoundingClientRect();
    const textLayer = pageNode.querySelector('.textLayer');
    const textRect = textLayer.getBoundingClientRect();

    for (let line of lines) {
        const box = document.createElement('div');
        box.className = type + '-box';

        box.style.left = (textRect.left - pageRect.left) + 'px';
        box.style.top = (line.top - pageRect.top) + 'px';
        box.style.width = textRect.width + 'px';
        box.style.height = line.height + 'px';

        box.onclick = () => box.remove();
        pageNode.appendChild(box);
    }

    clearSelection();
}



    document.addEventListener('mouseup', (e) => {
        const sel = window.getSelection();
        if (sel.toString().trim()) {
            selectedRange = sel.getRangeAt(0);
            menu.style.display = 'flex';
            menu.style.left = e.clientX + 'px'; menu.style.top = (e.clientY - 50) + 'px';
        } else if (!e.target.closest('#floating-menu')) menu.style.display = 'none';
    });

    function exportNotes() {
        // Xu·∫•t to√†n b·ªô m·∫£ng allNotes, m·∫£ng n√†y ƒë√£ ch·ª©a c√°c chu·ªói format c√≥ master_id
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(allNotes, null, 2));
        const dlAnchor = document.createElement('a');
        dlAnchor.setAttribute("href", dataStr);
        dlAnchor.setAttribute("download", "pdf_study_full_data.json");
        dlAnchor.click();
    }

    function showNoteForm() {
        document.getElementById('form-source').innerText =
    selectedRange ? extractTextByRects(selectedRange) : iosSelection.text;
        document.getElementById('note-form-overlay').style.display = 'flex';
        menu.style.display = 'none';
    }
    function closeForm() { document.getElementById('note-form-overlay').style.display = 'none'; }
    function closeSidebar() { sidebar.classList.remove('open'); }
    function clearSelection() { window.getSelection().removeAllRanges(); menu.style.display = 'none'; }
</script>
</body>
</html>